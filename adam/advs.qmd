---
title: "ADVS"
order: 6
---

```{r setup script, include=FALSE, purl=FALSE}
invisible_hook_purl <- function(before, options, ...) {knitr::hook_purl(before, options, ...); NULL}
knitr::knit_hooks$set(purl = invisible_hook_purl)
```

# Introduction

This article provides a step-by-step explanation for creating an ADaM `ADVS` (Vital Signs) dataset using key pharmaverse packages along with tidyverse components.

For the purpose of this example, we will use the `ADSL` dataset from `{pharmaverseadam}` and `vs` domain from `{pharmaversesdtm}`.

# Load Data and Required pharmaverse Packages

First we will load the packages required for our project. We will use `{admiral}` for the creation of analysis data. `{admiral}` requires `{dplyr}`, `{lubridate}` and `{stringr}`. We will use `{metacore}` and `{metatools}` to store and manipulate metadata from our specifications. We will use `{xportr}` to perform checks on the final data and export to a transport file.

Then we will load our input data.

```{r setup, message=FALSE, warning=FALSE, results='hold'}
library(metacore)
library(metatools)
library(pharmaversesdtm)
library(admiral)
library(xportr)
library(dplyr)
library(tidyr)
library(lubridate)
library(stringr)

# Read in input data
adsl <- pharmaverseadam::adsl
vs <- pharmaversesdtm::vs

vs <- convert_blanks_to_na(vs)
```

# Load Specifications for Metacore

We have saved our specifications in an Excel file and will load them into `{metacore}` with the `metacore::spec_to_metacore()` function.

```{r echo=TRUE}
#| label: Load Specs
#| warning: false
# ---- Load Specs for Metacore ----
metacore <- spec_to_metacore(
  path = "./metadata/ADSL_ADVS_spec.xlsx",
  where_sep_sheet = FALSE,
  quiet = TRUE
) %>%
  select_dataset("ADVS")
```

# Select ADSL Variables

Some variables from the `ADSL` dataset required for the derivations are merged into the `VS` domain using the `admiral::derive_vars_merged()` function.
The rest of the relevant `ADSL` variables would be added later.

```{r}
# Select required ADSL variables
adsl_vars <- exprs(TRTSDT, TRTEDT, TRT01A, TRT01P)

# Join ADSL variables with VS
advs <- vs %>%
  derive_vars_merged(
    dataset_add = adsl,
    new_vars = adsl_vars,
    by_vars = exprs(STUDYID, USUBJID)
  )

head(advs, n=10)
```

# Start Building Derivations

The first derivation step we are going to do is to compute the Analysis Date and Relative Analysis Day with the variables merged from `ADSL` dataset.
The resulting dataset has the 2 columns created.

```{r}
# Calculate ADT, ADY
  advs <- advs %>% 
  derive_vars_dt(
    new_vars_prefix = "A",
    dtc = VSDTC,
    # Below arguments are default values and not necessary to add in our case
    highest_imputation = "n", # means no imputation is performed on partial/missing dates
    flag_imputation = "auto" # To automatically create ADTF variable when highest_imputation is "Y", "M" or "D"
  ) %>%
  derive_vars_dy(
    reference_date = TRTSDT,
    source_vars = exprs(ADT)
  )

head(advs %>% select(STUDYID, USUBJID, VISIT, VISITNUM, VSTESTCD, VSTEST, VSDTC, !!!adsl_vars, ADT, ADY), n=10)
```

## Assign `PARAMCD`, `PARAM`, `PARAMN`

To assign parameter level values such as `PARAMCD`, `PARAM`, `PARAMN`,
etc., a lookup can be created to join to the source data.

For example, when creating `ADVS`, a lookup based on the SDTM `--TESTCD` value 
may be created:

`VSTESTCD` | `PARAMCD` | `PARAM` | `PARAMN` 
--------- | --------- | -------- | ------- 
SYSBP | SYSBP | Systolic Blood Pressure (mmHg) | 1
DIABP | DIABP | Diastolic Blood Pressure (mmHg) | 2
PULSE | PULSE | Pulse Rate (beats/min) | 3
WEIGHT | WEIGHT | Weight (kg) | 4
HEIGHT | HEIGHT | Height (cm) | 5
TEMP | TEMP | Temperature (C) | 6
MAP | MAP | Mean Arterial Pressure | 7
BMI | BMI | Body Mass Index(kg/m^2) | 8
BSA | BSA | Body Surface Area(m^2) | 9

This lookup may now be joined to the source data:

```{r eval=TRUE, include=FALSE}
param_lookup <- tibble::tribble(
  ~VSTESTCD, ~PARAMCD,                            ~PARAM, ~PARAMN,
  "SYSBP",    "SYSBP", " Systolic Blood Pressure (mmHg)",        1,
  "DIABP",    "DIABP", "Diastolic Blood Pressure (mmHg)",        2,
  "PULSE",    "PULSE",          "Pulse Rate (beats/min)",        3,
  "WEIGHT",  "WEIGHT",                     "Weight (kg)",        4,
  "HEIGHT", "HEIGHT",                      "Height (cm)",        5,
  "TEMP",     "TEMP",                  "Temperature (C)",        6,
  "MAP",       "MAP",    "Mean Arterial Pressure (mmHg)",        7,
  "BMI",       "BMI",          "Body Mass Index(kg/m^2)",        8,
  "BSA",       "BSA",           "Body Surface Area(m^2)",        9
)
attr(param_lookup$VSTESTCD, "label") <- "Vital Signs Test Short Name"
```

At this stage, only `PARAMCD` is required to perform the derivations. Additional
derived parameters may be added, so only `PARAMCD` is joined to the datasets at
this point. All other variables related to `PARAMCD` (e.g. `PARAM`, `PARAMN`, ...)
will be added when all `PARAMCD` are derived.

```{r}
advs <- advs %>%
  # Add PARAMCD only - add PARAM etc later
  derive_vars_merged_lookup(
    dataset_add = param_lookup,
    new_vars = exprs(PARAMCD),
    by_vars = exprs(VSTESTCD),
    # Below arguments are default values and not necessary to add in our case
    print_not_mapped = TRUE # Printing whether some parameters are not mapped
  )

head(advs %>% select(STUDYID, USUBJID, VISIT, VISITNUM, VSTESTCD, VSTEST, VSDTC, !!!adsl_vars, ADT, ADY, PARAMCD), n=10)
```

## Derive Results and Units (`AVAL`, `AVALU`)

The mapping of `AVAL` and `AVALU` is left to the ADaM programmer. An 
example mapping may be:

```{r eval=TRUE}
advs <- advs %>% 
  mutate(
    AVAL = VSSTRESN,
    AVALU = VSSTRESU
  ) 

head(advs %>% select(STUDYID, USUBJID, VISIT, VISITNUM, VSTESTCD, VSTEST, VSDTC, !!!adsl_vars, ADT, ADY, PARAMCD, AVAL, AVALU), n=10)
```

In this example, as is often the case for ADVS, all `AVAL` values are numeric without any corresponding non-redundant text value for `AVALC`.
Per recommendation in ADaMIG v1.3 we do not map `AVALC`.

## Derive Additional Parameters (e.g. `MAP`, `BMI` or `BSA` for `ADVS`)

Optionally derive new parameters creating `PARAMCD` and `AVAL`. Note that only
variables specified in the `by_vars` argument will be populated in the newly 
created records. This is relevant to the functions `derive_param_map`, 
`derive_param_bsa`, `derive_param_bmi`, and `derive_param_qtc`. 

Below is an example of creating `Mean Arterial Pressure` for `ADVS` using the wrapper function `admiral::derive_param_map()` 

```{r eval=TRUE}
advs <- advs %>% 
  derive_param_map(
    by_vars = exprs(STUDYID, USUBJID, !!!adsl_vars, VISIT, VISITNUM, ADT, ADY, VSTPT, VSTPTNUM, AVALU), # Other variables than the defined ones here won't be populated
    set_values_to = exprs(PARAMCD = "MAP"),
    get_unit_expr = VSSTRESU,
    filter = VSSTAT != "NOT DONE" | is.na(VSSTAT),
    # Below arguments are default values and not necessary to add in our case
    sysbp_code = "SYSBP",
    diabp_code = "DIABP",
    hr_code = NULL
  )
```

Similarly we could create `Body Mass Index` (BMI) for `ADVS` using the wrapper function `admiral::derive_param_bmi()`, instead we will see in below example
how to use the more generic function `admiral::derive_param_computed()`
Note that if height is collected only once use `constant_parameters` to define the corresponding parameter which will be merged to the other parameters and `constant_by_vars` to specify the subject-level variable to merge on.
Otherwise BMI is only calculated for visits where both parameters `HEIGHT` and `WEIGHT` are collected.

```{r eval=TRUE}
advs <- advs %>% 
  derive_param_computed(
    by_vars = exprs(STUDYID, USUBJID, VISIT, VISITNUM, ADT, ADY, VSTPT, VSTPTNUM),
    parameters = "WEIGHT",
    set_values_to = exprs(
      AVAL = AVAL.WEIGHT / (AVAL.HEIGHT / 100)^2,
      PARAMCD = "BMI",
      AVALU = "kg/m^2"
    ),
    constant_parameters = c("HEIGHT"),
    constant_by_vars = exprs(USUBJID)
  )
```

Likewise, wrapper function `admiral::derive_param_bsa()` call below, to create parameter `Body Surface Area` (BSA) for `ADVS` domain.
Note that if height is collected only once use `constant_by_vars` to specify the subject-level variable to merge on.
Otherwise BSA is only calculated for visits where both parameters `HEIGHT` and `WEIGHT` are collected.

```{r eval=TRUE}
advs <- advs %>% 
  derive_param_bsa(
    by_vars = exprs(STUDYID, USUBJID, !!!adsl_vars, VISIT, VISITNUM, ADT, ADY, VSTPT, VSTPTNUM),
    method = "Mosteller",
    set_values_to = exprs(
      PARAMCD = "BSA",
      AVALU = "m^2"
    ),
    get_unit_expr = VSSTRESU,
    filter = VSSTAT != "NOT DONE" | is.na(VSSTAT),
    constant_by_vars = exprs(USUBJID),
    # Below arguments are default values and not necessary to add in our case
    height_code = "HEIGHT",
    weight_code = "WEIGHT"
  )
```

```{r, eval=TRUE, echo=FALSE}
head(advs %>% filter(PARAMCD == "MAP") %>% select(STUDYID, USUBJID, VSTESTCD, PARAMCD, VISIT, VSTPT, AVAL, AVALU), n=10)
```
```{r, eval=TRUE, echo=FALSE}
head(advs %>% filter(PARAMCD == "BMI") %>% select(STUDYID, USUBJID, VSTESTCD, PARAMCD, VISIT, VSTPT, AVAL, AVALU), n=10)
```
```{r, eval=TRUE, echo=FALSE}
head(advs %>% filter(PARAMCD == "BSA") %>% select(STUDYID, USUBJID, VSTESTCD, PARAMCD, VISIT, VSTPT, AVAL, AVALU), n=10)
```

## Derive Timing Variables (e.g. `AVISIT`, `ATPT`, `ATPTN`)

Categorical timing variables are protocol and analysis dependent. Below is a simple example. 

```{r eval=TRUE}
advs <- advs %>%
  mutate(
    ATPTN = VSTPTNUM,
    ATPT = VSTPT,
    AVISIT = case_when(
      str_detect(VISIT, "SCREEN|UNSCHED|RETRIEVAL|AMBUL") ~ NA_character_,
      !is.na(VISIT) ~ str_to_title(VISIT),
      TRUE ~ NA_character_
    ),
    AVISITN = as.numeric(case_when(
      VISIT == "BASELINE" ~ "0",
      str_detect(VISIT, "WEEK") ~ str_trim(str_replace(VISIT, "WEEK", "")),
      TRUE ~ NA_character_
    ))
  )
```

For assigning visits based on time windows and deriving periods, subperiods, and phase variables see
the ["Visit and Period Variables" vignette](visits_periods.html).

## Derive summary records (e.g. mean of the triplicates at each time point) ----

For adding new records based on aggregating records `derive_summary_records()`
can be used. For the new records only the variables specified by `by_vars` and
`set_values_to` are populated.

For each subject, Vital Signs parameter, visit, and date add a record holding
the average value for observations on that date.
Set `DTYPE` to `AVERAGE`.

```{r eval=TRUE}
advs <- derive_summary_records(
  dataset = advs,
  dataset_add = advs, # Observations from the specified dataset are going to be used to calculate and added as new records to the input dataset.
  by_vars = exprs(STUDYID, USUBJID, !!!adsl_vars, PARAMCD, AVISITN, AVISIT, ADT, ADY, AVALU),
  filter_add = !is.na(AVAL),
  set_values_to = exprs(
    AVAL = mean(AVAL),
    DTYPE = "AVERAGE"
  )
)
```

## Timing Flag Variables (e.g. `ONTRTFL`)

In some analyses, it may be necessary to flag an observation as on-treatment.
The admiral function `derive_var_ontrtfl()` can be used.

For example, if on-treatment is defined as any observation between treatment
start and treatment end, the flag may be derived as:

```{r eval=TRUE}
advs <- derive_var_ontrtfl(
  advs,
  start_date = ADT,
  ref_start_date = TRTSDT,
  ref_end_date = TRTEDT,
  filter_pre_timepoint = toupper(AVISIT) == "BASELINE" # Observations as not on-treatment
)
```

```{r, eval=TRUE, echo=FALSE}
head(advs %>% filter(PARAMCD == "DIABP" & toupper(VISIT) == "WEEK 2") %>% select(USUBJID, PARAMCD, ADT, TRTSDT, TRTEDT, ONTRTFL), n=10)
```

## Assign Reference Range Indicator (`ANRIND`)

The admiral function `derive_var_anrind()` may be used to derive the reference
range indicator `ANRIND`.

This function requires the reference range boundaries to exist on the data frame 
(`ANRLO`, `ANRHI`) and also accommodates the additional boundaries `A1LO` and `A1HI`.

```{r include=FALSE}
range_lookup <- tibble::tribble(
  ~PARAMCD, ~ANRLO, ~ANRHI, ~A1LO, ~A1HI,
  "SYSBP",      90,    130,    70,   140,
  "DIABP",      60,     80,    40,    90,
  "PULSE",      60,    100,    40,   110,
  "TEMP",     36.5,   37.5,    35,    38
)

advs <- derive_vars_merged(
  advs,
  dataset_add = range_lookup,
  by_vars = exprs(PARAMCD)
)
```

The function is called as:

```{r eval=TRUE}
advs <- derive_var_anrind(advs)
```

```{r, eval=TRUE, echo=FALSE}
head(advs %>% filter(PARAMCD == "DIABP" & toupper(VISIT) == "WEEK 2") %>% select(USUBJID, PARAMCD, AVAL, ANRLO, ANRHI, A1LO, A1HI, ANRIND), n=10)
```